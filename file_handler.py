"""
Name: file_handler.py
Authors: Logan Hoadley, Adan Narvaez Munguia

This file contains helper functions to assist with preparing machine data for analysis.
"""
from datetime import datetime
import csv


def is_wide_form(csv_file):
    """
    Determines whether the file is formatted in wide-form or not. If not, it is likely longform.
    Longform files are generated by PI Vision, and need to be converted to wide-form.
    :param csv_file: The csv file, as a Pandas dataframe.
    :return: True if it is in wide-form, false if it is in longform.
    """
    if csv_file.columns[0] == "Data Source":
        return False
    else:
        return True


def correct_timestamp(timestamp):
    """
    Corrects the ISO timestamps by appending the truncated zeros until they are recognizable by Python.
    Afterwards, the timestamp is altered to display only seconds of precision.
    :type timestamp: basestring
    :param timestamp: An ISO formatted timestamp as a string.
    :return: The ISO formatted timestamp, with the milliseconds removed.
    """
    try:
        # Append a 0 to the end of the timestamp.
        corrected_timestamp = timestamp + "0"
        # Attempt to convert it to a Python datetime object.
        datetime_timestamp = datetime.fromisoformat(corrected_timestamp)
        # If it succeeds, convert it back to the ISO format, with milliseconds removed.
        return datetime_timestamp.isoformat(sep=' ', timespec='seconds')
    # If there still aren't enough digits, recurse.
    except ValueError:
        timestamp = timestamp + "0"
        return correct_timestamp(timestamp)


def file_correct(file):
    # TODO: Delete this function or retool it to process files already in Wide-Form.
    # iterates downloaded data from OSI and removes the unnecessary tags for the file location from the processing
    for i in file.index:
        sourcename = str(file.loc[i, 'Data Source'])
        sourcetime = str(file.loc[i, 'Time'])
        file.loc[i, 'Data Source'] = sourcename.rpartition('\\')[-1]
        # file.loc[i,'Data Source']=sourcename.removeprefix
        # ("\\\\TUSSITCDIIPIAF\TUS_TC_PROD_v7\_PRIMARY_L1_EQUIPMENT\GUILIN_04\\")
        # this is an unbelievably stupid way of correcting the time but it's what my little gremlin brain came up with
        file.loc[i, 'Time'] = '-'.join(sourcetime.rpartition('.')[0:-2])
        if file.loc[i, 'Time'] != '':
            try:
                sourcestamp = datetime.fromisoformat(file.loc[i, 'Time'])
                file.loc[i, 'Time'] = sourcestamp.isoformat(sep=' ', timespec='seconds')
            except ValueError:
                file.loc[i, 'Time'] = correct_timestamp(file.loc[i, 'Time'])
    print("header:")
    print(file.columns)
    print("data at index 0")
    print(file.loc[1])

    # print(file.loc[i, 'Time'])
    # file = file.groupby(file.index).sum()
    # print(file)
    # df2 = file.pivot(index='Time', columns='Data Source', values='Value')
    # print(df2)


def long_to_wide(input_file):
    """
    This function takes a longform factory provided CSV file and converts into a wide-form dictionary.
    Values are sorted under timestamps at each second.
    Gaps between seconds are filled in, as these gaps are caused by the machine's storage saving algorithm, where it is
    presumed that the sensors are not detecting perceptible changes in the reading.
    This dictionary is structured to be interpreted as a CSV table.
    :type input_file: basestring
    :param input_file: The name of the csv file, as a string.
    :return: A wide-form table stored in a dictionary.
    """
    # Dictionary to store csv data in
    wide_dict = {}
    wide_data = []
    # List to store all the data sources for headers
    sources = ['Time']
    with open(input_file, encoding='utf-8-sig') as csv_file:
        reader = csv.DictReader(csv_file)
        for row in reader:
            if row['Time'] != '':
                # The timestamps are stored in ISO format down to millisecond precision.
                # Unfortunately, the milliseconds are often truncated such that Python does not recognize the stamp.
                # When this happens, a ValueError is caught and passed to a corrective function.
                try:
                    time_stamp = datetime.fromisoformat(row['Time'])
                    time_stamp = time_stamp.isoformat(sep=' ', timespec='seconds')
                except ValueError:
                    time_stamp = correct_timestamp(row['Time'])
                # Collecting the datasource and the value, and formatting the datasource appropriately.
                source = row['Data Source']
                value = row['Value']
                source = source.rpartition('\\')[-1]
                # If the source is not in the sources list, append it.
                if source not in sources:
                    sources.append(source)
                # If the timestamp isn't in the dictionary yet, insert it as a new key.
                if time_stamp not in wide_dict:
                    wide_dict[time_stamp] = {'Time': time_stamp, source: float(value)}
                else:
                    # If it exists already, update the value of the source in this row.
                    wide_dict[time_stamp][source] = float(value)
    with open('test.csv', 'w', newline='') as output_file:
        writer = csv.DictWriter(output_file, fieldnames=sources)
        # Headers are defined at the beginning of the script.
        writer.writeheader()
        # Dictionary of last known values, for filling in the gaps in the data.
        # Initialized to blank spaces.
        last_known_values = {}
        for s in sources:
            last_known_values[s] = None
        # Traverse the values in chronological order
        for key in sorted(wide_dict.keys()):
            # For each header, check if a value exists at that location, if not, then set it to last known value.
            for s in sources:
                if s not in wide_dict[key] or wide_dict[key][s] == '':
                    if last_known_values[s] is None:
                        wide_dict[key][s] = None
                    else:
                        wide_dict[key][s] = float(last_known_values[s])
                # If value exists at this location, update last known value.
                else:
                    last_known_values[s] = wide_dict[key][s]
            wide_data.append(wide_dict[key])
    return wide_data, sources
